/**
 * 这道题matrix上的测试样例有问题，就算AC了也不代表代码是正确的
 * 真想练的话，LeetCode上有原题
 * 实验课上为了gkd去看理论题，方法比较偷鸡（虽然人家matrix也不管
 * O(n^3)暴力解法：
 * 先求一个前缀和，然后穷举所有合法的区间组合(三层for)
 * 通过前缀和预处理后，求每个区间的区间和都是O(1)的，可以节省不少时间
 * 
 * 
 * 这道题比较正统的解法是动态规划，状态转移方程dp[i][j]=max(dp[i-1][j],sum[i]+dp[i-k][j-1])
 * i表示只考虑下标小于等于i的值(前缀和)，j表示已经选定了几个区间
 * 事实上这种解法是这类题目的通解，可以求任意m个长度为k的区间的最大区间和
 * 此题为m=3的情况
 * 
 * 下面的解法是针对这题的情况的特殊做法，比较容易理解，时间复杂度为O(n)
 * 核心思想为假设中间的子数组已选定，那么我们只需找到左边区间和最大的数组和右边区间和最大的数组即可
 * 那么只需枚举中间区间的所有可能即可
 * 思路：
 * 先求一个区间和数组s，记录所有长度为k的区间和，s[i]表示a[i]到a[i+k-1]的和
 * 求数组l,r，l[i]记录下标小于等于i的max(s[i])，r[i]记录下标大于等于i的max(s[i])  (注意两个数组创建时有所区别，这与字典序最小的要求有关)
 * 通过数组l,r，对于任意的中间区间，我们都可以直接查询到合法的左右最大区间
 */


#include <iostream>
using namespace std;
#define ll long long
const int N=20005;
ll a[N],s[N],l[N],r[N];

int main()
{
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=k;i++) s[1]+=a[i];
    for(int i=2;i<=n-k+1;i++)//求区间和
    {
        s[i]=(s[i-1]-a[i-1]+a[i+k-1]);
    }


    l[1]=1;
    for(int i=2;i<=n-k+1;i++)
    {
        if(s[i]>s[l[i-1]]) l[i]=i;//这里是大于号，因为要满足字典序最小
        else l[i]=l[i-1];
    }
    r[n-k+1]=n-k+1;
    for(int i=n-k;i>=1;i--)
    {
        if(s[i]>=s[r[i+1]]) r[i]=i;//这里是>=，理由同上
        else r[i]=r[i+1];
    }


    int x=0,y=0,z=0;
    ll sum=0;
    for(int i=k+1;i<=n-2*k+1;i++)
    {
        if(s[l[i-k]]+s[i]+s[r[i+k]]>sum)//三个区间之和较大的话，更新记录的索引
        {
            sum=s[l[i-k]]+s[i]+s[r[i+k]];
            x=l[i-k];
            y=i;
            z=r[i+k];
        }
    }
    cout<<x-1<<","<<y-1<<","<<z-1<<endl;//我习惯索引从0开始，但是题目要求从0开始，微调一下
}


